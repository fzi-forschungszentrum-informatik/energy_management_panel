# Generated by Django 3.1 on 2020-09-21 19:24

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Datapoint',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('external_id', models.PositiveIntegerField(blank=True, help_text="This id used if Datapoints data is pushed in from an external tool (e.g. BEMCom) that maintains it's own list datapoint metadata. This field allows matching the ids of the external tools with the database table of the EMP, effectively allowing the EMP to store Datapoints additionally to what is pushed from the external tool, e.g. for mock (fake) values.", null=True, unique=True)),
                ('type', models.CharField(choices=[('sensor', 'Sensor'), ('actuator', 'Actuator')], default=None, help_text='Datapoint type, can be ether sensor or actuator.', max_length=8)),
                ('data_format', models.CharField(choices=[('generic_numeric', 'Generic Numeric'), ('continuous_numeric', 'Continuous Numeric'), ('discrete_numeric', 'Discrete Numeric'), ('generic_text', 'Generic Text'), ('discrete_text', 'Discrete Text')], default='generic_text', help_text='Format of the datapoint value. Additionally defines which metadata is available for it. See documentation in code for details.', max_length=18)),
                ('description', models.TextField(blank=True, help_text='A human readable description of the datapoint targeted on users of the API wihtout knowledge about connector details.')),
                ('last_value', models.TextField(blank=True, default=None, help_text='The last value received for the datapoint. We store all values including numeric as strings as this simplfies the logic significantly and prevents unintended side effects, e.g. data loss if the data format field is changed.', null=True)),
                ('last_value_timestamp', models.DateTimeField(blank=True, default=None, help_text='The timestamp of the last value received via MQTT.', null=True)),
                ('last_setpoint', models.JSONField(blank=True, default=None, help_text='The last schedule received for the datapoint. Applicable to actuator datapoints.', null=True)),
                ('last_setpoint_timestamp', models.DateTimeField(blank=True, default=None, help_text='The timestamp of the last value received for the datapoint.Applicable to actuator datapoints.', null=True)),
                ('last_schedule', models.JSONField(blank=True, default=None, help_text='The last schedule received for the datapoint.Applicable to actuator datapoints.', null=True)),
                ('last_schedule_timestamp', models.DateTimeField(blank=True, default=None, help_text='The timestamp of the last value received for the datapoint.Applicable to actuator datapoints.', null=True)),
                ('allowed_values', models.JSONField(blank=True, default=None, help_text='Allowed values. Applicable to discrete valued datapoints. Must be a valid JSON string.', null=True)),
                ('min_value', models.FloatField(blank=True, default=None, help_text='The minimal expected value of the datapoint. Applicable to numeric datapoints.', null=True)),
                ('max_value', models.FloatField(blank=True, default=None, help_text='The maximal expected value of the datapoint. Applicable to numeric datapoints.', null=True)),
                ('unit', models.TextField(blank=True, default='', help_text='The unit in SI notation, e.g.  Mg*m*s^-2 aka. kN. Applicable to numeric datapoints.')),
            ],
        ),
    ]
